--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

block update:
    remainingTransactions = current.transactions - block.transactions
    targetAssembly = assemble(remainingTransactions)

    // ---

    spawns = []
    walks = []

    for tx in block.transactions:
        case inside top block:
            no walk

        case inside another block:
            add walk WalkIn(top block)

        case inside waiting:
            WalkIn(top block)

        case absent:
            add spawn
            add walk WalkIn(top block)

    yieldOuts = []
    yieldIns = []

    for tx in targetAssembly:
        // compute nextPlacmentOnce
        if tx.placement == waiting:
            walks.add(tx, waiting)
        else if tx.placement == bus
            nextBus = bus + 1
            if nextBus == OVERFLOW_BUS:
                yieldOuts.push(walk tx waiting)
                yieldIns.push(walk tx nextBus - 1)

            else if nextBus != oldAssembly.tx.bus:
                walks.push(tx, nextBus)

    cmd(spawns)
    cmd(walks)
    cmd(yieldOuts)
    cmd(driveoff)
        top bus leaves
        others move ahead
        new bus is spawned at the end
    cmd(yieldIns)


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

pa = none | wait | block(a)
pb = wait | block(b)

none => wait:
    house(const y) -> walklane
    walklane(const x) -> y of wait
    walklane(const y) -> x of wait

none => block(b)
    house(const y) -> walklane
    walklane(const x) -> y of block(b)
    walklane(const y) -> x of block(b)

wait => block(b)
    wait(const x) -> y of block(b)
    wait(const y) -> x of block(b)

block(a) => wait
    block(a)(const y) -> x of wait
    wait -> y of wait

block(a) => block(b)
    block(a)(const y) -> x of wait
    wait => block(b)

