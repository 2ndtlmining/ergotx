repeatedly call API:
    calculate delta
    emit events (new tx, new block)

on tx:
    update person

on block:
    update bus


API:

get mempool

    http://213.239.193.208:9053/transactions/unconfirmed?limit=90&offset=0

    https://api.ergoplatform.com/transactions/unconfirmed?limit=8&sortBy=size&sortDirection=desc
    sortBy:
        creationtimestamp
        size

    a few, 20-30 tx at most

get confirmed blocks

    http://213.239.193.208:9053/blocks?limit=50&offset=0
    returns the blocks (well, only block ids) starting at the given offset, so this call actually returns the very first 50 blocks in the blockchain

    https://api.ergoplatform.com/api/v1/blocks?limit=1&offset=0&sortBy=height&sortDirection=desc

    sortBy:
        blockcoins
        blockfee
        difficulty
        height
        minerreward
        size
        timestamp
        transactionscount


 <h2>Mempool</h2>
<p>Count: <span id="mempool-count">0</span></p>

<!-- prettier-ignore-start -->
<pre><code id="mempool"></code></pre>
<!-- prettier-ignore-end -->

<h2>Lastest Block</h2>

<!-- prettier-ignore-start -->
<pre><code id="latest-block"></code></pre>
<!-- prettier-ignore-end -->

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

TODO:

handle events in queue instead of calling funcions syncrhonomously


PLAN:

    add busses
    add a transaction to bus
    leave bus

buses:
    tx killed:
        is in waiting zone:

    tx:
        new txs go to waiting or inside a bus
        old txs get outside of bus (to waiting) or change bus

    block:
        These two in parallel
        |____|extra txs inside top bus (if any) go to waiting or prev bus
             |waiting txs of this block (if any) go inside top bus

        These two in parallel
        |____|top bus goes to leaving
             |prev buses move to forward




(Block[], WaitingTx[]) MakeBlockTemplates(mempool) {

}

enum Location {
    Home(...),
    Waiting,
    Bus(index),
    Destroy
}

TxMoveCommand[] TxStateDelta(old, new) {
    let oldTx = TxLocations(old);
    let newTx = TxLocations(old);

    let commands = [];

    for tx in newTx + oldTx:
        let oldLocation;
        let targetLocation;

        if tx in oldTx:
                oldLocation = oldTx[tx]
            else
                oldLocation = TxHome(tx)

        if tx in newTx:
            targetLocation = newTx[tx]
        else
            targetLocation = DESTROY

        if oldLocation != targetLocation:
            commands.push({ tx: tx, from: oldLocation, to: targetLocation })
}


void OnTxs(tx: Tx[]) {
    mempool = CombineMempoolWithAge(mempool, txs) // also sets the appropriate location: Home() or Waiting

    let newBlockTemplates = MakeBlockTemplates(mempool + txs);
    let commands = TxStateDelta(oldBlockTemplates, newBlockTemplates)

    // each command can be run in parallel

    for cmd in commands:
        cmd.tx.executeCommand(cmd)
}