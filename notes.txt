
get mempool

    http://213.239.193.208:9053/transactions/unconfirmed?limit=90&offset=0

    https://api.ergoplatform.com/transactions/unconfirmed?limit=8&sortBy=size&sortDirection=desc
    sortBy:
        creationtimestamp
        size

    a few, 20-30 tx at most

get confirmed blocks

    http://213.239.193.208:9053/blocks?limit=50&offset=0
    returns the blocks (well, only block ids) starting at the given offset, so this call actually returns the very first 50 blocks in the blockchain

    https://api.ergoplatform.com/api/v1/blocks?limit=1&offset=0&sortBy=height&sortDirection=desc

    sortBy:
        blockcoins
        blockfee
        difficulty
        height
        minerreward
        size
        timestamp
        transactionscount



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

TODO:


buses:
    tx killed:
        is in waiting zone:

    tx:
        new txs go to waiting or inside a bus
        old txs get outside of bus (to waiting) or change bus

    block:
        These two in parallel
        |____|(1) extra txs inside top bus (if any) go to waiting or prev bus
             |(2) waiting txs of this block (if any) go inside top bus
             |(3) non existant txs of this block spawn and go inside the top bus

        These two in parallel
        |____|(4) top bus goes to leaving
             |(5) prev buses move to forward


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

block update:
    remainingTransactions = current.transactions - block.transactions
    targetAssembly = assemble(remainingTransactions)

    // ---

    spawns = []
    walks = []

    for tx in block.transactions:
        case inside top block:
            no walk

        case inside another block:
            add walk WalkIn(top block)

        case inside waiting:
            WalkIn(top block)

        case absent:
            add spawn
            add walk WalkIn(top block)

    yieldOuts = []
    yieldIns = []

    for tx in targetAssembly:
        // compute nextPlacmentOnce
        if tx.placement == waiting:
            walks.add(tx, waiting)
        else if tx.placement == bus
            nextBus = bus + 1
            if nextBus == OVERFLOW_BUS:
                yieldOuts.push(walk tx waiting)
                yieldIns.push(walk tx nextBus - 1)

            else if nextBus != oldAssembly.tx.bus:
                walks.push(tx, nextBus)

    cmd(spawns)
    cmd(walks)
    cmd(yieldOuts)
    cmd(driveoff)
    cmd(yieldIns)


