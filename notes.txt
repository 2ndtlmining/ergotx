--------------------------------------------------------------------------------

https://api.ergoplatform.com/api/v0/info
- supply
- hashRate

https://api.ergoplatform.com/api/v0/stats
- miningCost.hashRate
- blockSummary.averageMiningTime
- transactionsSummary.total (Transactions today (well, per day))
- transactionsSummary.totalFee (total fee from transactions today (above))

https://erg-oracle-ergusd.spirepools.com/frontendData
https://api.coingecko.com/api/v3/simple/price?ids=ergo&vs_currencies=usd

remaining:
- price
- average fee


the miner (output) box is the one with "ergoTree" value equal to:

100204a00b08cd02eeec374f4e660e117fccbfec79e6fe5cdf44ac508fa228bfc654d2973f9bdc9aea02d192a39a8cc7a70173007301

This is the (encoded) `ErgoScriptPredef.feeProposition` smart contract

--------------------------------------------------------------------------------

block update:
    remainingTransactions = current.transactions - block.transactions
    targetAssembly = assemble(remainingTransactions)

    // ---

    spawns = []
    walks = []

    for tx in block.transactions:
        case inside top block:
            no walk

        case inside another block:
            add walk WalkIn(top block)

        case inside waiting:
            WalkIn(top block)

        case absent:
            add spawn
            add walk WalkIn(top block)

    yieldOuts = []
    yieldIns = []

    for tx in targetAssembly:
        // compute nextPlacmentOnce
        if tx.placement == waiting:
            walks.add(tx, waiting)
        else if tx.placement == bus
            nextBus = bus + 1
            if nextBus == OVERFLOW_BUS:
                yieldOuts.push(walk tx waiting)
                yieldIns.push(walk tx nextBus - 1)

            else if nextBus != oldAssembly.tx.bus:
                walks.push(tx, nextBus)

    cmd(spawns)
    cmd(walks)
    cmd(yieldOuts)
    cmd(step_forward)
        top bus leaves
        others move ahead
        new bus is spawned at the end
    cmd(yieldIns)


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

pa = none | wait | block(a)
pb = wait | block(b)

none => wait:
    house(const y) -> walklane
    walklane(const x) -> y of wait
    walklane(const y) -> x of wait

none => block(b)
    house(const y) -> walklane
    walklane(const x) -> y of block(b)
    walklane(const y) -> x of block(b)

wait => block(b)
    wait(const x) -> y of block(b)
    wait(const y) -> x of block(b)

block(a) => wait
    block(a)(const y) -> x of wait
    wait -> y of wait

block(a) => block(b)
    block(a)(const y) -> x of wait
    wait => block(b)

